/*
 * ATM_RFIDRelay.cpp
 *
 * Basic structure autogenerated on www.wolkendek.nl/atm/editor.php
 *
 */

#include <ATM_RFIDRelay.h>
#include <functional>

const char client_host[] = "192.168.0.220";

/*** Some black magic with lambda functions.
 * Automaton does not support lambdas for callback, except if they
 * don't capture any variable and have the exact signature as needed.
 * (In that case, lambdas are the same as the "old-style" function pointers).
 * Therefore offer a global function, so it can be called in such a simple lambda.
 * This global function then calls a "real lambda" that has been set before.
 */

std::function<void()> gLFct;
void triggerResponseWrap() {gLFct();}
void setResponseWrap(std::function<void()> lfct) {gLFct = lfct;}


/* Add optional parameters for the state machine to begin()
 * Add extra initialization code
 */

ATM_RFIDRelay& ATM_RFIDRelay::begin() {
  // clang-format off
  const static state_t state_table[] PROGMEM = {
    /*                                           ON_ENTER  ON_LOOP            ON_EXIT         EVT_EV_OFF  EVT_TIMER_REJ_NOTIFY    EVT_TIMER_MAXON      EVT_EV_AUTHREJ  EVT_EV_AUTHCONF  EVT_EV_AUTHREQ        EVT_EV_CONNLOST   EVT_EV_CONNECTED  ELSE */
    /*     NO_CONNECTION_OFF */     ENT_NO_CONNECTION_OFF,      -1,                -1,                -1,                   -1,                -1,                 -1,              -1,             -1,                    -1,     CONNECTED_OFF,   -1,
    /* NO_CONNECTION_BRIDGED */ ENT_NO_CONNECTION_BRIDGED,      -1,                -1,                -1,                   -1,                -1,                 -1,              -1,             -1,                    -1, CONNECTED_BRIDGED,   -1,
    /*         CONNECTED_OFF */         ENT_CONNECTED_OFF,      -1,                -1,                -1,                   -1,                -1,                 -1,              -1,  CONNECTED_CIP,     NO_CONNECTION_OFF,                -1,   -1,
    /*          CONNECTED_ON */          ENT_CONNECTED_ON,      -1,                -1,     CONNECTED_OFF,                   -1,     CONNECTED_OFF,                 -1,              -1,  CONNECTED_CIP,          CONNECTED_ON,                -1,   -1,
    /*         CONNECTED_CIP */         ENT_CONNECTED_CIP,      -1, EXT_CONNECTED_CIP,     CONNECTED_OFF,                   -1,                -1, CONNECTED_REJECTED,    CONNECTED_ON,             -1,     NO_CONNECTION_OFF,                -1,   -1,
    /*     CONNECTED_BRIDGED */     ENT_CONNECTED_BRIDGED,      -1,                -1,                -1,                   -1,                -1,                 -1,              -1,             -1, NO_CONNECTION_BRIDGED,                -1,   -1,
    /*    CONNECTED_REJECTED */    ENT_CONNECTED_REJECTED,      -1,                -1,     CONNECTED_OFF,        CONNECTED_OFF,                -1,                 -1,              -1,             -1,     NO_CONNECTION_OFF,                -1,   -1,
    /*      NO_CONNECTION_ON */      ENT_NO_CONNECTION_ON,      -1,                -1, NO_CONNECTION_OFF,                   -1, NO_CONNECTION_OFF,                 -1,              -1,             -1,                    -1,                -1,   -1,
  };
  // clang-format on
	Machine::begin(state_table, ELSE);

	//                1s  1m 1h
	timer_max_on.set(1000 * 60 * 60); // CONFIG: Set maximum duration to keep the relay on after connection was lost
	timer_rej_notify.set(4000);	// CONFIG: Set duration how long to notify REJECTION

	gpio.begin(); // CONFIG: use default address 0x20


	// CONFIG: Initialize inputs
	switch_off.begin(0).onPress(*this, EVT_EV_OFF);  // Button 0 switches off

	setResponseWrap([this]() {triggerResponse();});
	httpClient.begin(client_host, 80).onFinish([]( int idx, int v, int up ) {
		triggerResponseWrap();
	});
	httpClient.trace(Serial);

	// CONFIG: Initialize outputs with MCP23017 PINs
	led_rxtx.begin(5, true).trace(Serial);
	led_conn.begin(6, true).trace(Serial);
	bit_switch.begin(8).trace(Serial);
	buzzer.begin(7).trace(Serial);

	led_rxtx.off();
	led_conn.off();
	bit_switch.off();
	buzzer.off();


	return *this;
}

/* Add C++ code for each internally handled event (input)
 * The code must return 1 to trigger the event
 */

int ATM_RFIDRelay::event( int id ) {
  switch ( id ) {
	case EVT_EV_OFF:
	      return 0;
    case EVT_TIMER_REJ_NOTIFY:
      return timer_rej_notify.expired(this);
    case EVT_TIMER_MAXON:
      return timer_max_on.expired(this);
    // For now, the following events are triggered externally only
    case EVT_EV_AUTHREJ:
      return 0;
    case EVT_EV_AUTHCONF:
      return 0;
    case EVT_EV_AUTHREQ:
      return 0;
    case EVT_EV_CONNLOST:
      return 0;
    case EVT_EV_CONNECTED:
      return 0;
  }
  return 0;
}

/* Add C++ code for each action
 * This generates the 'output' for the state machine
 */

void ATM_RFIDRelay::action(int id) {
	switch (id) {
	case ENT_NO_CONNECTION_OFF:
		led_conn.off();
		bit_switch.off();
		buzzer.off();
		//buzzer.blink(800,500,3);	// 3 Long BEEP
		return;
	case ENT_NO_CONNECTION_BRIDGED:
		buzzer.blink(200, 60000);	// BEEP every minute
		return;
	case ENT_CONNECTED_OFF:
		led_rxtx.off();		// switch off LED after notification of rejection
		led_conn.blink();			//FIXME: Test only
		buzzer.blink();
		//buzzer.blink(200, 500, 5);  //FIXME: Test only
		bit_switch.on();
		return;
	case ENT_CONNECTED_ON:
		timer_max_on.set(1000 * 60 * 180); // 3 hours
		buzzer.blink(50, 100, 1);	// 1 very short BEEP
		led_conn.on();
		return;
	case ENT_CONNECTED_CIP:
		led_rxtx.blink(40, 60);
		return;
	case EXT_CONNECTED_CIP:	//TODO: Cancel pending request
	      return;
	case ENT_CONNECTED_BRIDGED:
		buzzer.blink(200, 60000);	// BEEP every minute
		return;
	case ENT_CONNECTED_REJECTED:
		led_rxtx.on();		// switch on LED permanently to notify about rejection
		buzzer.blink(200,100,3);  // 3 short BEEP
		return;
	case ENT_NO_CONNECTION_ON:
		timer_max_on.set(1000 * 60 * 60); // 1 hour
		led_conn.blink(500);
		return;
	}
}


// ****** Internal helper methods ******

void ATM_RFIDRelay::triggerResponse() {
	Serial.printf("Response %d received.\n", httpClient.responseCode());
	if (httpClient.responseCode() == 200) ev_authconf(); else ev_authrej();
}

void ATM_RFIDRelay::triggerRequest(uint16_t id) {
	Serial.printf("Request-ID %04x\n", id);
	if (httpClient.state() != Atm_esp8266_httpc_simple::IDLE) {
		Serial.println("Request pending");
		return;
	}
	ev_authreq();
	String requestString("/RFID-Relais/reqID");  // CONFIG: HTTP-Request-String
	String requestData("GID=");
	requestData.concat(id);
	httpClient.get(requestString, requestData).start();
}

/* Optionally override the default trigger() method
 * Control how your machine processes triggers
 */

ATM_RFIDRelay& ATM_RFIDRelay::trigger( int event ) {
  Machine::trigger( event );
  return *this;
}

/* Optionally override the default state() method
 * Control what the machine returns when another process requests its state
 */

int ATM_RFIDRelay::state( void ) {
  return Machine::state();
}

/* Public event methods
 * ** Be careful:
 *    They will be overwritten by the online state machine editor
 *    So save them before.
 */
ATM_RFIDRelay& ATM_RFIDRelay::ev_off() {
  trigger( EVT_EV_OFF );
  return *this;
}

ATM_RFIDRelay& ATM_RFIDRelay::ev_authrej() {
	trigger(EVT_EV_AUTHREJ);
	return *this;
}

ATM_RFIDRelay& ATM_RFIDRelay::ev_authconf() {
	led_rxtx.off();
	trigger(EVT_EV_AUTHCONF);
	return *this;
}

ATM_RFIDRelay& ATM_RFIDRelay::ev_authreq() {
	trigger(EVT_EV_AUTHREQ);
	return *this;
}

ATM_RFIDRelay& ATM_RFIDRelay::ev_connlost() {
	led_conn.off();
	trigger(EVT_EV_CONNLOST);
	return *this;
}

ATM_RFIDRelay& ATM_RFIDRelay::ev_connected() {
	Serial.println("Connected, switching LED_CONN to ON");
	led_conn.on();
	trigger(EVT_EV_CONNECTED);
	return *this;
}

/* State trace method
 * Sets the symbol table and the default logging method for serial monitoring
 */

ATM_RFIDRelay& ATM_RFIDRelay::trace( Stream & stream ) {
  Machine::setTrace( &stream, atm_serial_debug::trace,
    "RFIDRELAY\0EVT_EV_OFF\0EVT_TIMER_REJ_NOTIFY\0EVT_TIMER_MAXON\0EVT_EV_AUTHREJ\0EVT_EV_AUTHCONF\0EVT_EV_AUTHREQ\0EVT_EV_CONNLOST\0EVT_EV_CONNECTED\0ELSE\0NO_CONNECTION_OFF\0NO_CONNECTION_BRIDGED\0CONNECTED_OFF\0CONNECTED_ON\0CONNECTED_CIP\0CONNECTED_BRIDGED\0CONNECTED_REJECTED\0NO_CONNECTION_ON" );
  return *this;
}


